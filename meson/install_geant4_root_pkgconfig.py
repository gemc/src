#!/usr/bin/env python3

import subprocess
import os
import shutil

def run_config(command, option):
    """Run a config command with the given option and return the output."""
    result = subprocess.run([command, option], capture_output=True, text=True, check=True)
    return result.stdout.strip()


def filter_unwanted_flags(flags):
    """Remove unwanted flags related to Qt, CLHEP, and XercesC."""
    #unwanted = ["CLHEP", "clhep", "xercesc", "XercesC", "TreePlayer", "-Wshadow"]
    unwanted = ["Qt", "qt", "CLHEP", "clhep", "xercesc", "XercesC", "TreePlayer", "-Wshadow"]
    return " ".join(flag for flag in flags.split() if not any(uw in flag for uw in unwanted))


def filter_root_flags(flags, root_list):
    """Keep only specified ROOT libraries."""
    return " ".join(flag for flag in flags.split() if "-L" in flag or any(f"-l{lib}" in flag for lib in root_list))


def generate_pkgconfig(config_cmd, output_filename, name, description, root_list=None):
    """Generate a .pc file for pkg-config."""
    prefix = run_config(config_cmd, "--prefix")
    libs = filter_unwanted_flags(run_config(config_cmd, "--libs"))
    cflags = filter_unwanted_flags(run_config(config_cmd, "--cflags"))
    version = run_config(config_cmd, "--version")

    if config_cmd == "root-config" and root_list:
        libs = filter_root_flags(libs, root_list)
    else:
        libs = filter_unwanted_flags(libs)
        cflags = filter_unwanted_flags(cflags)

    pc_content = f"""
prefix={prefix}
exec_prefix=${{prefix}}
libdir=${{prefix}}/lib
includedir=${{prefix}}/include
   
Name: {name}
Description: {description}
Version: {version}
Cflags: {cflags}
Libs:  {libs}
    """.strip()

    # Write to the .pc file
    pc_file_path = os.path.join(os.environ["GEMC"], "lib", "pkgconfig", output_filename)
    os.makedirs(os.path.dirname(pc_file_path), exist_ok=True)
    with open(pc_file_path, "w") as pc_file:
        pc_file.write(pc_content + "\n")

    print(f"Generated {pc_file_path}")

def get_xercesc_paths():
    """Determine XercesC include and library paths using $XERCESCROOT."""
    xercesc_root = os.getenv("XERCESCROOT")
    if not xercesc_root:
        raise EnvironmentError("XERCESCROOT environment variable is not set.")

    include_dir = os.path.join(xercesc_root, "include")

    # Determine whether lib or lib64 exists
    lib_dir = os.path.join(xercesc_root, "lib")
    if not os.path.isdir(lib_dir):
        lib_dir = os.path.join(xercesc_root, "lib64")

    # Use appropriate library file depending on OS
    if os.uname().sysname == "Darwin":  # macOS
        library_release = os.path.join(lib_dir, "libxerces-c.dylib")
    else:  # Linux
        library_release = os.path.join(lib_dir, "libxerces-c-3.2.so")

    return include_dir, library_release

def generate_geant4_package_cache(output_filename):
    """Generate Geant4PackageCache.cmake with dynamically determined XercesC paths."""
    xercesc_include, xercesc_lib = get_xercesc_paths()

    cmake_content = f"""# This file should have been generated by the Geant4 CMake buildsystem but it's not

macro(geant4_set_and_check_package_variable _name _value _type _docstring)
    if(DEFINED ${{_name}})
        if(NOT ("${{${{_name}}}}" STREQUAL "${{_value}}"))
            message(WARNING "Value of '${{_name}}' is already set and does not match value set at Geant4 build-time")
        endif()
    else()
        set(${{_name}} ${{_value}} CACHE ${{_type}} "${{_docstring}}")
    endif()
endmacro()

# XercesC Build Time Settings
geant4_set_and_check_package_variable(XercesC_INCLUDE_DIR "{xercesc_include}" PATH "Xerces-C++ include directory")
geant4_set_and_check_package_variable(XercesC_LIBRARY_RELEASE "{xercesc_lib}" FILEPATH "Xerces-C++ libraries (release)")
"""

    g4lib_cmake_dir = os.path.join(os.getenv("G4LIB"), "cmake", "Geant4")
    os.makedirs(g4lib_cmake_dir, exist_ok=True)
    output_path = os.path.join(g4lib_cmake_dir, output_filename)

    with open(output_path, "w") as cmake_file:
        cmake_file.write(cmake_content + "\n")

    print(f"Installed {output_path}")

def check_root_config():
    """Check if root-config is available."""
    return shutil.which("root-config") is not None

# generate_geant4_package_cache is no longer necessary if the package cache is generated by the Geant4 CMake build system
if __name__ == "__main__":
    generate_pkgconfig("geant4-config", "geant4.pc", "Geant4", "Geant4 Simulation Toolkit")
    if check_root_config():
        root_list = ["RIO", "Tree", "Core", "root"]
        generate_pkgconfig("root-config", "root.pc", "ROOT", "ROOT Data Analysis Framework", root_list)
    #generate_geant4_package_cache("Geant4PackageCache.cmake")
